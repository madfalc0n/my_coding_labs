# 프로그래머스 카카오 문제

## 1 완료

카카오에 입사한 신입 개발자 `네오`는 카카오계정개발팀에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. 네오에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.
다음은 카카오 아이디의 규칙입니다.

- 아이디의 길이는 3자 이상 15자 이하여야 합니다.
- 아이디는 알파벳 소문자, 숫자, 빼기(`-`), 밑줄(`_`), 마침표(`.`) 문자만 사용할 수 있습니다.
- 단, 마침표(`.`)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.

네오는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.
신규 유저가 입력한 아이디가 `new_id` 라고 한다면,

```
1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.
2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.
3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.
4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.
5단계 new_id가 빈 문자열이라면, new_id에 "a"를 대입합니다.
6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.
     만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.
7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.
```

------

예를 들어, new_id 값이 ...!@BaT#*..y.abcdefghijklm 라면, 위 7단계를 거치고 나면 new_id는 아래와 같이 변경됩니다.

1단계 대문자 'B'와 'T'가 소문자 'b'와 't'로 바뀌었습니다.
`"...!@BaT#*..y.abcdefghijklm"` → `"...!@bat#*..y.abcdefghijklm"`

2단계 '!', '@', '#', '*' 문자가 제거되었습니다.
`"...!@bat#*..y.abcdefghijklm"` → `"...bat..y.abcdefghijklm"`

3단계 '...'와 '..' 가 '.'로 바뀌었습니다.
`"...bat..y.abcdefghijklm"` → `".bat.y.abcdefghijklm"`

4단계 아이디의 처음에 위치한 '.'가 제거되었습니다.
`".bat.y.abcdefghijklm"` → `"bat.y.abcdefghijklm"`

5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다.
`"bat.y.abcdefghijklm"` → `"bat.y.abcdefghijklm"`

6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다.
`"bat.y.abcdefghijklm"` → `"bat.y.abcdefghi"`

7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다.
`"bat.y.abcdefghi"` → `"bat.y.abcdefghi"`

따라서 신규 유저가 입력한 new_id가 ...!@BaT#*..y.abcdefghijklm일 때, 네오의 프로그램이 추천하는 새로운 아이디는 bat.y.abcdefghi 입니다.

------

#### **[문제]**

신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, 네오가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요.

#### **[제한사항]**

new_id는 길이 1 이상 1,000 이하인 문자열입니다.
new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.
new_id에 나타날 수 있는 특수문자는 `-_.~!@#$%^&*()=+[{]}:?,<>/` 로 한정됩니다.

------

##### **[입출력 예]**

| no   | new_id                          | result              |
| ---- | ------------------------------- | ------------------- |
| 예1  | `"...!@BaT#*..y.abcdefghijklm"` | `"bat.y.abcdefghi"` |
| 예2  | `"z-+.^."`                      | `"z--"`             |
| 예3  | `"=.="`                         | `"aaa"`             |
| 예4  | `"123_.def"`                    | `"123_.def"`        |
| 예5  | `"abcdefghijklmn.p"`            | `"abcdefghijklmn"`  |

##### **입출력 예에 대한 설명**

------

**입출력 예 #1**
문제의 예시와 같습니다.

**입출력 예 #2**
7단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다.

1단계 변화 없습니다.
2단계 `"z-+.^."` → `"z-.."`
3단계 `"z-.."` → `"z-."`
4단계 `"z-."` → `"z-"`
5단계 변화 없습니다.
6단계 변화 없습니다.
7단계 `"z-"` → `"z--"`

**입출력 예 #3**
7단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다.

1단계 변화 없습니다.
2단계 `"=.="` → `"."`
3단계 변화 없습니다.
4단계 `"."` → `""` (new_id가 빈 문자열이 되었습니다.)
5단계 `""` → `"a"`
6단계 변화 없습니다.
7단계 `"a"` → `"aaa"`

**입출력 예 #4**
1단계에서 7단계까지 거치는 동안 new_id(123_.def)는 변하지 않습니다. 즉, new_id가 처음부터 카카오의 아이디 규칙에 맞습니다.

**입출력 예 #5**
1단계 변화 없습니다.
2단계 변화 없습니다.
3단계 변화 없습니다.
4단계 변화 없습니다.
5단계 변화 없습니다.
6단계 `"abcdefghijklmn.p"` → `"abcdefghijklmn."` → `"abcdefghijklmn"`
7단계 변화 없습니다.

## 2

레스토랑을 운영하던 `스카피`는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다.
기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋을 지 고민하던 스카피는 이전에 각 손님들이 주문할 때 가장 많이 함께 주문한 단품메뉴들을 코스요리 메뉴로 구성하기로 했습니다.
단, 코스요리 메뉴는 최소 2가지 이상의 단품메뉴로 구성하려고 합니다. 또한, 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다.

예를 들어, 손님 6명이 주문한 단품메뉴들의 조합이 다음과 같다면,
(각 손님은 단품메뉴를 2개 이상 주문해야 하며, 각 단품메뉴는 A ~ Z의 알파벳 대문자로 표기합니다.)

| 손님 번호 | 주문한 단품메뉴 조합 |
| --------- | -------------------- |
| 1번 손님  | A, B, C, F, G        |
| 2번 손님  | A, C                 |
| 3번 손님  | C, D, E              |
| 4번 손님  | A, C, D, E           |
| 5번 손님  | B, C, F, G           |
| 6번 손님  | A, C, D, E, H        |

가장 많이 함께 주문된 단품메뉴 조합에 따라 스카피가 만들게 될 코스요리 메뉴 구성 후보는 다음과 같습니다.

| 코스 종류     | 메뉴 구성  | 설명                                                 |
| ------------- | ---------- | ---------------------------------------------------- |
| 요리 2개 코스 | A, C       | 1번, 2번, 4번, 6번 손님으로부터 총 4번 주문됐습니다. |
| 요리 3개 코스 | C, D, E    | 3번, 4번, 6번 손님으로부터 총 3번 주문됐습니다.      |
| 요리 4개 코스 | B, C, F, G | 1번, 5번 손님으로부터 총 2번 주문됐습니다.           |
| 요리 4개 코스 | A, C, D, E | 4번, 6번 손님으로부터 총 2번 주문됐습니다.           |

------

#### **[문제]**

각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, 스카피가 `추가하고 싶어하는` 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, 스카피가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.

#### **[제한사항]**

- orders 배열의 크기는 2 이상 20 이하입니다.

- orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다.

  - 각 문자열은 알파벳 대문자로만 이루어져 있습니다.
  - 각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다.

- course 배열의 크기는 1 이상 10 이하입니다.

  - course 배열의 각 원소는 2 이상 10 이하인 자연수가 `오름차순`으로 정렬되어 있습니다.
  - course 배열에는 같은 값이 중복해서 들어있지 않습니다.

- 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로

   

  ```
  오름차순
  ```

   

  정렬해서 return 해주세요.

  - 배열의 각 원소에 저장된 문자열 또한 알파벳 `오름차순`으로 정렬되어야 합니다.
  - 만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다.
  - orders와 course 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다.

------

##### **[입출력 예]**

| orders                                              | course  | result                              |
| --------------------------------------------------- | ------- | ----------------------------------- |
| `["ABCFG", "AC", "CDE", "ACDE", "BCFG", "ACDEH"]`   | [2,3,4] | `["AC", "ACDE", "BCFG", "CDE"]`     |
| `["ABCDE", "AB", "CD", "ADE", "XYZ", "XYZ", "ACD"]` | [2,3,5] | `["ACD", "AD", "ADE", "CD", "XYZ"]` |
| `["XYZ", "XWY", "WXA"]`                             | [2,3,4] | `["WX", "XY"]`                      |

##### **입출력 예에 대한 설명**

------

**입출력 예 #1**
문제의 예시와 같습니다.

**입출력 예 #2**
AD가 세 번, CD가 세 번, ACD가 두 번, ADE가 두 번, XYZ 가 두 번 주문됐습니다.
요리 5개를 주문한 손님이 1명 있지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 5개로 구성된 코스요리는 새로 추가하지 않습니다.

**입출력 예 #3**
WX가 두 번, XY가 두 번 주문됐습니다.
3명의 손님 모두 단품메뉴를 3개씩 주문했지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 3개로 구성된 코스요리는 새로 추가하지 않습니다.
또, 단품메뉴를 4개 이상 주문한 손님은 없으므로, 요리 4개로 구성된 코스요리 또한 새로 추가하지 않습니다.

## 3 효율성뺴고 맞음

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다.

- 코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다.
- 지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다.
- 지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다.
- 선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다.

인재영입팀에 근무하고 있는 `니니즈`는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다.
예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다.
`코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가?`

물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다.

- 코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?
- 코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?
- backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가?
- 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가?
- 코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가?

즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다.

```
* [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?
```

------

#### **[문제]**

지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때,
각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.

#### **[제한사항]**

- info 배열의 크기는 1 이상 50,000 이하입니다.

- info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친

   

  개발언어 직군 경력 소울푸드 점수

   

  형식입니다.

  - 개발언어는 cpp, java, python 중 하나입니다.
  - 직군은 backend, frontend 중 하나입니다.
  - 경력은 junior, senior 중 하나입니다.
  - 소울푸드는 chicken, pizza 중 하나입니다.
  - 점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다.
  - 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.

- query 배열의 크기는 1 이상 100,000 이하입니다.

- query의 각 문자열은

   

  [조건] X

   

  형식입니다.

  - [조건]은 개발언어 and 직군 and 경력 and 소울푸드 형식의 문자열입니다.
  - 언어는 cpp, java, python, - 중 하나입니다.
  - 직군은 backend, frontend, - 중 하나입니다.
  - 경력은 junior, senior, - 중 하나입니다.
  - 소울푸드는 chicken, pizza, - 중 하나입니다.
  - '-' 표시는 해당 조건을 고려하지 않겠다는 의미입니다.
  - X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다.
  - 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.
  - 예를 들면, cpp and - and senior and pizza 500은 cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?를 의미합니다.

------

##### **[입출력 예]**

| info                                                         | query                                                        | result        |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------- |
| `["java backend junior pizza 150","python frontend senior chicken 210","python frontend senior chicken 150","cpp backend senior pizza 260","java backend junior chicken 80","python backend senior chicken 50"]` | `["java and backend and junior and pizza 100","python and frontend and senior and chicken 200","cpp and - and senior and pizza 250","- and backend and senior and - 150","- and - and - and chicken 100","- and - and - and - 150"]` | [1,1,1,1,2,4] |

##### **입출력 예에 대한 설명**

지원자 정보를 표로 나타내면 다음과 같습니다.

| 언어   | 직군     | 경력   | 소울 푸드 | 점수 |
| ------ | -------- | ------ | --------- | ---- |
| java   | backend  | junior | pizza     | 150  |
| python | frontend | senior | chicken   | 210  |
| python | frontend | senior | chicken   | 150  |
| cpp    | backend  | senior | pizza     | 260  |
| java   | backend  | junior | chicken   | 80   |
| python | backend  | senior | chicken   | 50   |

- `"java and backend and junior and pizza 100"` : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다.
- `"python and frontend and senior and chicken 200"` : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다.
- `"cpp and - and senior and pizza 250"` : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다.
- `"- and backend and senior and - 150"` : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다.
- `"- and - and - and chicken 100"` : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다.
- `"- and - and - and - 150"` : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다.

## 4

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

밤늦게 귀가할 때 안전을 위해 항상 택시를 이용하던 `무지`는 최근 야근이 잦아져 택시를 더 많이 이용하게 되어 택시비를 아낄 수 있는 방법을 고민하고 있습니다. 무지는 자신이 택시를 이용할 때 동료인 `어피치` 역시 자신과 비슷한 방향으로 가는 택시를 종종 이용하는 것을 알게 되었습니다. 무지는 어피치와 귀가 방향이 비슷하여 택시 합승을 적절히 이용하면 택시요금을 얼마나 아낄 수 있을 지 계산해 보고 어피치에게 합승을 제안해 보려고 합니다.

![2021_kakao_taxi_01.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/715ff493-d1a0-44d8-9273-a785280b3f1e/2021_kakao_taxi_01.png)

위 예시 그림은 택시가 이동 가능한 반경에 있는 6개 지점 사이의 이동 가능한 택시노선과 예상요금을 보여주고 있습니다.
그림에서 `A`와 `B` 두 사람은 출발지점인 4번 지점에서 출발해서 택시를 타고 귀가하려고 합니다. `A`의 집은 6번 지점에 있으며 `B`의 집은 2번 지점에 있고 두 사람이 모두 귀가하는 데 소요되는 예상 최저 택시요금이 얼마인 지 계산하려고 합니다.

- 그림의 원은 지점을 나타내며 원 안의 숫자는 지점 번호를 나타냅니다.
  - 지점이 n개일 때, 지점 번호는 1부터 n까지 사용됩니다.
- 지점 간에 택시가 이동할 수 있는 경로를 간선이라 하며, 간선에 표시된 숫자는 두 지점 사이의 예상 택시요금을 나타냅니다.
  - 간선은 편의 상 직선으로 표시되어 있습니다.
  - 위 그림 예시에서, 4번 지점에서 1번 지점으로(4→1) 가거나, 1번 지점에서 4번 지점으로(1→4) 갈 때 예상 택시요금은 `10`원으로 동일하며 이동 방향에 따라 달라지지 않습니다.
- 예상되는 최저 택시요금은 다음과 같이 계산됩니다.
  - 4→1→5 : `A`, `B`가 합승하여 택시를 이용합니다. 예상 택시요금은 `10 + 24 = 34`원 입니다.
  - 5→6 : `A`가 혼자 택시를 이용합니다. 예상 택시요금은 `2`원 입니다.
  - 5→3→2 : `B`가 혼자 택시를 이용합니다. 예상 택시요금은 `24 + 22 = 46`원 입니다.
  - `A`, `B` 모두 귀가 완료까지 예상되는 최저 택시요금은 `34 + 2 + 46 = 82`원 입니다.

------

#### **[문제]**

지점의 개수 n, 출발지점을 나타내는 s, `A`의 도착지점을 나타내는 a, `B`의 도착지점을 나타내는 b, 지점 사이의 예상 택시요금을 나타내는 fares가 매개변수로 주어집니다. 이때, `A`, `B` 두 사람이 s에서 출발해서 각각의 도착 지점까지 택시를 타고 간다고 가정할 때, 최저 예상 택시요금을 계산해서 return 하도록 solution 함수를 완성해 주세요.
만약, 아예 합승을 하지 않고 각자 이동하는 경우의 예상 택시요금이 더 낮다면, 합승을 하지 않아도 됩니다.

#### **[제한사항]**

- 지점갯수 n은 3 이상 200 이하인 자연수입니다.

- 지점 s, a, b는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.

  - 즉, 출발지점, `A`의 도착지점, `B`의 도착지점은 서로 겹치지 않습니다.

- fares는 2차원 정수 배열입니다.

- fares 배열의 크기는 2 이상

   

  ```
  n x (n-1) / 2
  ```

   

  이하입니다.

  - 예를들어, n = 6이라면 fares 배열의 크기는 2 이상 15 이하입니다. (`6 x 5 / 2 = 15`)
  - fares 배열의 각 행은 [c, d, f] 형태입니다.
  - c지점과 d지점 사이의 예상 택시요금이 `f`원이라는 뜻입니다.
  - 지점 c, d는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.
  - 요금 f는 1 이상 100,000 이하인 자연수입니다.
  - fares 배열에 두 지점 간 예상 택시요금은 1개만 주어집니다. 즉, [c, d, f]가 있다면 [d, c, f]는 주어지지 않습니다.

- 출발지점 s에서 도착지점 a와 b로 가는 경로가 존재하는 경우만 입력으로 주어집니다.

------

##### **[입출력 예]**

| n    | s    | a    | b    | fares                                                        | result |
| ---- | ---- | ---- | ---- | ------------------------------------------------------------ | ------ |
| 6    | 4    | 6    | 2    | [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]] | 82     |
| 7    | 3    | 4    | 1    | [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]]      | 14     |
| 6    | 4    | 5    | 6    | [[2,6,6], [6,3,7], [4,6,7], [6,5,11], [2,5,12], [5,3,20], [2,4,8], [4,3,9]] | 18     |

##### **입출력 예에 대한 설명**

------

**입출력 예 #1**
문제 예시와 같습니다.

**입출력 예 #2**
![2021_kakao_taxi_02.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/934fcb5a-f844-4b02-b7fa-46198123be05/2021_kakao_taxi_02.png)

- 합승을 하지 않고, `B`는 `3→2→1`, `A`는 `3→6→4` 경로로 각자 택시를 타고 가는 것이 최저 예상 택시요금입니다.
- 따라서 최저 예상 택시요금은 `(3 + 6) + (1 + 4) = 14`원 입니다.

**입출력 예 #3**
![2021_kakao_taxi_03.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/179cc8ad-73d2-46c9-95e9-2363f3cb345d/2021_kakao_taxi_03.png)

- `A`와 `B`가 `4→6` 구간을 합승하고 `B`가 6번 지점에서 내린 후, `A가`6→5` 구간을 혼자 타고 가는 것이 최저 예상 택시요금입니다.
- 따라서 최저 예상 택시요금은 `7 + 11 = 18`원 입니다.

## 5

`카카오TV`에서 유명한 크리에이터로 활동 중인 `죠르디`는 환경 단체로부터 자신의 가장 인기있는 동영상에 지구온난화의 심각성을 알리기 위한 공익광고를 넣어 달라는 요청을 받았습니다. 평소에 환경 문제에 관심을 가지고 있던 죠르디는 요청을 받아들였고 광고효과를 높이기 위해 시청자들이 가장 많이 보는 구간에 공익광고를 넣으려고 합니다. 죠르디는 시청자들이 해당 동영상의 어떤 구간을 재생했는 지 알 수 있는 재생구간 기록을 구했고, 해당 기록을 바탕으로 공익광고가 삽입될 최적의 위치를 고를 수 있었습니다.
참고로 광고는 재생 중인 동영상의 오른쪽 아래에서 원래 영상과 `동시에 재생되는` PIP(Picture in Picture) 형태로 제공됩니다.

![2021_kakao_cf_01.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/597ec277-4451-4289-8817-2970be644a69/2021_kakao_cf_01.png)

다음은 죠르디가 공익광고가 삽입될 최적의 위치를 고르는 과정을 그림으로 설명한 것입니다.
![2021_kakao_cf_02.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e733fafb-1e6b-4d30-bbab-a22f366229e7/2021_kakao_cf_02.png)

- 그림의 파란색 선은 광고를 검토 중인

   

  죠르디

   

  동영상의 전체 재생 구간을 나타냅니다.

  - 위 그림에서, 죠르디 동영상의 총 재생시간은 `02시간 03분 55초` 입니다.

- 그림의 검은색 선들은 각 시청자들이

   

  죠르디

  의 동영상을 재생한 구간의 위치를 표시하고 있습니다.

  - 검은색 선의 가운데 숫자는 각 재생 기록을 구분하는 ID를 나타냅니다.
  - 검은색 선에 표기된 왼쪽 끝 숫자와 오른쪽 끝 숫자는 시청자들이 재생한 동영상 구간의 시작 시각과 종료 시각을 나타냅니다.
  - 위 그림에서, 3번 재생 기록은 `00시 25분 50초` 부터 `00시 48분 29초` 까지 총 `00시간 22분 39초` 동안 죠르디의 동영상을 재생했습니다. [1](https://programmers.co.kr/tryouts/16422/challenges#fn1)
  - 위 그림에서, 1번 재생 기록은 `01시 20분 15초` 부터 `01시 45분 14초` 까지 총 `00시간 24분 59초` 동안 죠르디의 동영상을 재생했습니다.

- 그림의 빨간색 선은

   

  죠르디

  가 선택한 최적의 공익광고 위치를 나타냅니다.

  - 만약 공익광고의 재생시간이 `00시간 14분 15초`라면, 위의 그림처럼 `01시 30분 59초` 부터 `01시 45분 14초` 까지 공익광고를 삽입하는 것이 가장 좋습니다. 이 구간을 시청한 시청자들의 누적 재생시간이 가장 크기 때문입니다.

  - ```
    01시 30분 59초
    ```

     

    부터

     

    ```
    01시 45분 14초
    ```

     

    까지의 누적 재생시간은 다음과 같이 계산됩니다.

    - `01시 30분 59초` 부터 `01시 37분 44초` 까지 : 4번, 1번 재생 기록이 두차례 있으므로 재생시간의 합은 `00시간 06분 45초` X 2 = `00시간 13분 30초`
    - `01시 37분 44초` 부터 `01시 45분 14초` 까지 : 4번, 1번, 5번 재생 기록이 세차례 있으므로 재생시간의 합은 `00시간 07분 30초` X 3 = `00시간 22분 30초`
    - 따라서, 이 구간 시청자들의 누적 재생시간은 `00시간 13분 30초` + `00시간 22분 30초` = `00시간 36분 00초`입니다.

------

#### **[문제]**

죠르디의 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time, 시청자들이 해당 동영상을 재생했던 구간 정보 logs가 매개변수로 주어질 때, 시청자들의 누적 재생시간이 가장 많이 나오는 곳에 공익광고를 삽입하려고 합니다. 이때, 공익광고가 들어갈 `시작 시각`을 구해서 return 하도록 solution 함수를 완성해주세요. 만약, 시청자들의 누적 재생시간이 가장 많은 곳이 여러 곳이라면, 그 중에서 `가장 빠른 시작 시각`을 return 하도록 합니다.

#### **[제한사항]**

- play_time, adv_time은 길이 8로 고정된 문자열입니다.

  - play_time, adv_time은 `HH:MM:SS` 형식이며, `00:00:01` 이상 `99:59:59` 이하입니다.
  - 즉, 동영상 재생시간과 공익광고 재생시간은 `00시간 00분 1초` 이상 `99시간 59분 59초` 이하입니다.
  - 공익광고 재생시간은 동영상 재생시간보다 짧거나 같게 주어집니다.

- logs는 크기가 1 이상 300,000 이하인 문자열 배열입니다.

  - logs 배열의 각 원소는 시청자의 재생 구간을 나타냅니다.

  - logs 배열의 각 원소는 길이가 17로 고정된 문자열입니다.

  - logs 배열의 각 원소는

     

    ```
    H1:M1:S1-H2:M2:S2
    ```

     

    형식입니다.

    - `H1:M1:S1`은 동영상이 시작된 시각, `H2:M2:S2`는 동영상이 종료된 시각을 나타냅니다.
    - `H1:M1:S1`는 `H2:M2:S2`보다 1초 이상 이전 시각으로 주어집니다.
    - `H1:M1:S1`와 `H2:M2:S2`는 play_time 이내의 시각입니다.

- 시간을 나타내는 `HH, H1, H2`의 범위는 00~99, 분을 나타내는 `MM, M1, M2`의 범위는 00~59, 초를 나타내는 `SS, S1, S2`의 범위는 00~59까지 사용됩니다. 잘못된 시각은 입력으로 주어지지 않습니다. (예: `04:60:24`, `11:12:78`, `123:12:45` 등)

- return 값의 형식

  - 공익광고를 삽입할 시각을 `HH:MM:SS` 형식의 8자리 문자열로 반환합니다.

------

##### **[입출력 예]**

| play_time    | adv_time     | logs                                                         | result       |
| ------------ | ------------ | ------------------------------------------------------------ | ------------ |
| `"02:03:55"` | `"00:14:15"` | `["01:20:15-01:45:14", "00:40:31-01:00:00", "00:25:50-00:48:29", "01:30:59-01:53:29", "01:37:44-02:02:30"]` | `"01:30:59"` |
| `"99:59:59"` | `"25:00:00"` | `["69:59:59-89:59:59", "01:00:00-21:00:00", "79:59:59-99:59:59", "11:00:00-31:00:00"]` | `"01:00:00"` |
| `"50:00:00"` | `"50:00:00"` | `["15:36:51-38:21:49", "10:14:18-15:36:51", "38:21:49-42:51:45"]` | `"00:00:00"` |

##### **입출력 예에 대한 설명**

------

**입출력 예 #1**
문제 예시와 같습니다.

**입출력 예 #2**
![2021_kakao_cf_03.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0e58c7f5-2b81-43f2-95e1-c504f17aab9b/2021_kakao_cf_03.png)

`01:00:00`에 공익광고를 삽입하면 `26:00:00`까지 재생되며, 이곳이 가장 좋은 위치입니다. 이 구간의 시청자 누적 재생시간은 다음과 같습니다.

- `01:00:00-11:00:00` : 해당 구간이 1회(2번 기록) 재생되었으므로 누적 재생시간은 `10시간 00분 00초` 입니다.
- `11:00:00-21:00:00` : 해당 구간이 2회(2번, 4번 기록) 재생되었으므로 누적 재생시간은 `20시간 00분 00초` 입니다.
- `21:00:00-26:00:00` : 해당 구간이 1회(4번 기록) 재생되었으므로 누적 재생시간은 `05시간 00분 00초` 입니다.
- 따라서, 이 구간의 시청자 누적 재생시간은 `10시간 00분 00초` + `20시간 00분 00초` + `05시간 00분 00초` = `35시간 00분 00초` 입니다.
- 초록색으로 표시된 구간(`69:59:59-94:59:59`)에 광고를 삽입해도 동일한 결과를 얻을 수 있으나, `01:00:00`이 `69:59:59` 보다 빠른 시각이므로, `"01:00:00"`을 return 합니다.

**입출력 예 #3**
![2021_kakao_cf_04.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8e564c82-00ce-4e1a-80fc-5cd96e465a69/2021_kakao_cf_04.png)

동영상 재생시간과 공익광고 재생시간이 같으므로, 삽입할 수 있는 위치는 맨 처음(`00:00:00`)이 유일합니다.

------

1. `동영상 재생시간 = 재생이 종료된 시각 - 재생이 시작된 시각`(예를 들어, `00시 00분 01초`부터 `00시 00분 10초`까지 동영상이 재생되었다면, 동영상 재생시간은 `9초` 입니다.) [↩](https://programmers.co.kr/tryouts/16422/challenges#fnref1)

## 6

게임 개발자인 `베로니`는 개발 연습을 위해 다음과 같은 간단한 카드 짝맞추기 보드 게임을 개발해 보려고 합니다.
게임이 시작되면 화면에는 카드 16장이 뒷면을 위로하여 `4 x 4` 크기의 격자 형태로 표시되어 있습니다. 각 카드의 앞면에는 카카오프렌즈 캐릭터 그림이 그려져 있으며, 8가지의 캐릭터 그림이 그려진 카드가 각기 2장씩 화면에 무작위로 배치되어 있습니다.
유저가 카드를 2장 선택하여 앞면으로 뒤집었을 때 같은 그림이 그려진 카드면 해당 카드는 게임 화면에서 사라지며, 같은 그림이 아니라면 원래 상태로 뒷면이 보이도록 뒤집힙니다. 이와 같은 방법으로 모든 카드를 화면에서 사라지게 하면 게임이 종료됩니다.

게임에서 카드를 선택하는 방법은 다음과 같습니다.

- 카드는

   

  ```
  커서
  ```

  를 이용해서 선택할 수 있습니다.

  - 커서는 4 x 4 화면에서 유저가 선택한 현재 위치를 표시하는 굵고 빨간 테두리 상자를 의미합니다.

- 커서는 [Ctrl] 키와 방향키에 의해 이동되며 키 조작법은 다음과 같습니다.

  - 방향키 ←, ↑, ↓, → 중 하나를 누르면, 커서가 누른 키 방향으로 1칸 이동합니다.
  - [Ctrl] 키를 누른 상태에서 방향키 ←, ↑, ↓, → 중 하나를 누르면, 누른 키 방향에 있는 가장 가까운 카드로 한번에 이동합니다.
    - 만약, 해당 방향에 카드가 하나도 없다면 그 방향의 가장 마지막 칸으로 이동합니다.
  - 만약, 누른 키 방향으로 이동 가능한 카드 또는 빈 공간이 없어 이동할 수 없다면 커서는 움직이지 않습니다.

- 커서가 위치한 카드를 뒤집기 위해서는 [Enter] 키를 입력합니다.

  - [Enter] 키를 입력해서 카드를 뒤집었을 때
    - 앞면이 보이는 카드가 1장 뿐이라면 그림을 맞출 수 없으므로 두번째 카드를 뒤집을 때 까지 앞면을 유지합니다.
    - 앞면이 보이는 카드가 2장이 된 경우, 두개의 카드에 그려진 그림이 같으면 해당 카드들이 화면에서 사라지며, 그림이 다르다면 두 카드 모두 뒷면이 보이도록 다시 뒤집힙니다.

베로니는 게임 진행 중 카드의 짝을 맞춰 몇 장 제거된 상태에서 카드 앞면의 그림을 알고 있다면, 남은 카드를 모두 제거하는데 필요한 키 조작 횟수의 최솟값을 구해 보려고 합니다. 키 조작 횟수는 방향키와 [Enter] 키를 누르는 동작을 각각 조작 횟수 `1`로 계산하며, [Ctrl] 키와 방향키를 함께 누르는 동작 또한 조작 횟수 `1`로 계산합니다.

다음은 카드가 몇 장 제거된 상태의 게임 화면에서 커서를 이동하는 예시입니다.
아래 그림에서 빈 칸은 이미 카드가 제거되어 없어진 칸을 의미하며, 그림이 그려진 칸은 카드 앞 면에 그려진 그림을 나타냅니다.

![2021_kakao_card_01.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/bd1c06b3-6684-480a-85e6-53f1123b0770/2021_kakao_card_01.png)
예시에서 커서는 두번째 행, 첫번째 열 위치에서 시작하였습니다.
![2021_kakao_card_02.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8d9008a0-a933-44c7-92a8-96b701483d6e/2021_kakao_card_02.png)
[Enter] 입력, ↓ 이동, [Ctrl]+→ 이동, [Enter] 입력 = 키 조작 4회
![2021_kakao_card_03.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/89b256d7-b8a8-4fb1-a1f4-84407a029d03/2021_kakao_card_03.png)
[Ctrl]+↑ 이동, [Enter] 입력, [Ctrl]+← 이동, [Ctrl]+↓ 이동, [Enter] 입력 = 키 조작 5회
![2021_kakao_card_04.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/96b37dbd-bba1-47e0-89e5-7a3e518eab24/2021_kakao_card_04.png)
[Ctrl]+→ 이동, [Enter] 입력, [Ctrl]+↑ 이동, [Ctrl]+← 이동, [Enter] 입력 = 키 조작 5회

위와 같은 방법으로 커서를 이동하여 카드를 선택하고 그림을 맞추어 카드를 모두 제거하기 위해서는 총 14번(방향 이동 8번, [Enter] 키 입력 6번)의 키 조작 횟수가 필요합니다.

------

#### **[문제]**

현재 카드가 놓인 상태를 나타내는 2차원 배열 board와 커서의 처음 위치 r, c가 매개변수로 주어질 때, 모든 카드를 제거하기 위한 키 조작 횟수의 최솟값을 return 하도록 solution 함수를 완성해 주세요.

#### **[제한사항]**

- board는 4 x 4 크기의 2차원 배열입니다.
- board 배열의 각 원소는 0 이상 6 이하인 자연수입니다.
  - 0은 카드가 제거된 빈 칸을 나타냅니다.
  - 1 부터 6까지의 자연수는 2개씩 들어있으며 같은 숫자는 같은 그림의 카드를 의미합니다.
  - 뒤집을 카드가 없는 경우(board의 모든 원소가 0인 경우)는 입력으로 주어지지 않습니다.
- r은 커서의 최초 세로(행) 위치를 의미합니다.
- c는 커서의 최초 가로(열) 위치를 의미합니다.
- r과 c는 0 이상 3 이하인 정수입니다.
- 게임 화면의 좌측 상단이 (0, 0), 우측 하단이 (3, 3) 입니다.

------

##### **[입출력 예]**

| board                                     | r    | c    | result |
| ----------------------------------------- | ---- | ---- | ------ |
| [[1,0,0,3],[2,0,0,0],[0,0,0,2],[3,0,1,0]] | 1    | 0    | 14     |
| [[3,0,0,2],[0,0,1,0],[0,1,0,0],[2,0,0,3]] | 0    | 1    | 16     |

##### **입출력 예에 대한 설명**

------

**입출력 예 #1**
문제의 예시와 같습니다.

**입출력 예 #2**
입력으로 주어진 게임 화면은 아래 그림과 같습니다.

![2021_kakao_card_05.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/5c6e8d3f-2427-42b8-893b-5677cb45aa5d/2021_kakao_card_05.png)

위 게임 화면에서 모든 카드를 제거하기 위한 키 조작 횟수의 최솟값은 16번 입니다.

## 7

유통전문회사 `카카오상사`의 오너인 `제이지`는 새로운 사업 아이템을 구상하기 위해 전문경영인(CEO)인 `프로도`에게 회사의 경영을 부탁하였습니다.
카카오상사는 직원들을 여러 개의 팀 단위로 조직을 구성하고 있으며 아래 그림은 CEO를 포함하여 10명의 직원과 4개의 팀으로 구성되어 있는 회사 조직도를 보여주고 있습니다.
![2021_kakao_sales_01.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/a55bfc1d-951e-478f-bbe8-f5eb021e5a0d/2021_kakao_sales_01.png)
그림의 조직도는 다음과 같이 설명할 수 있습니다.

1. 그림의 각 원들은 각각의 직원 1명을 표시하고 있으며, CEO를 포함하여 총 10명의 직원을 표시하고 있습니다.
2. 원 안에 적힌 두 개의 숫자는 직원의 정보를 담고 있습니다. 왼쪽 숫자는 `직원번호`이며 직원을 식별할 수 있도록 1번부터 순서대로 발급되는 일련번호이며, 오른쪽 숫자는 `해당 직원의 하루평균 매출액`을 나타냅니다. 위 그림에서 `1번` 직원은 14원을, `9번` 직원은 28원의 하루평균 매출액을 기록하고 있습니다.
3. CEO를 포함하여 모든 직원은 팀장 또는 팀원이라는 직위를 가지고 있으며 그림에서는 팀장과 팀원의 관계를 화살표로 표시하고 있습니다. 화살표가 시작되는 쪽의 직원은 팀장, 화살표를 받는 쪽의 직원은 팀원을 의미합니다.
   3-1. 직원번호 `1번`은 회사의 CEO로 고정되어 있으며, CEO는 항상 팀장이고 팀원일 수 없어 화살표를 받는 쪽이 될 수 없습니다.
   3-2. 반면에 CEO를 제외한 나머지 모든 직원들은 다른 누군가로부터 정확히 1개의 화살표를 받게 됩니다.
   3-3. 한 직원은 최대 2개의 팀에 소속될 수 있습니다. 만약 어떤 직원이 두 개의 팀에 소속되어 있다면, 반드시 하나의 팀에서는 팀장, 나머지 팀에서는 팀원이어야 합니다. 팀장을 겸임하거나, 두 개의 팀에서 팀원이 될 수는 없습니다. 예를들어 `10번` 직원은 `D팀`의 팀장이면서 동시에 `5번` 직원이 팀장으로 있는 `C팀`에 속한 팀원입니다.
   3-4. `5번, 9번, 10번` 직원은 받는 쪽의 화살표와 시작하는 화살표가 모두 있으므로 팀장인 동시에 팀원입니다.
   3-5. `2번, 3번, 4번, 6번, 7번, 8번` 직원은 시작하는 화살표가 없고 받는 쪽의 화살표만 있으므로 팀장이 아니며 오직 팀원입니다.
   3-6. `1번` 직원인 CEO는 받는 쪽의 화살표가 없고 시작하는 화살표만 있으며 항상 팀원이 아닌 팀장입니다.
   3-7. 그림의 조직도에는 `A, B, C, D` 총 4개의 팀이 존재하며, 각각 `1번, 9번, 5번, 10번` 직원이 팀장 직위를 담당하게 됩니다.

제이지는 자신이 구상한 새로운 사업 아이템에 대해 직원들에게 설명하고자 하루 일정으로 워크숍을 계획하고 있습니다. 단, 모든 직원을 참석시킬 수 없어 아래와 같은 기준으로 워크숍에 참석할 직원들을 선발하려고 합니다.

1. 워크숍에서 교육받은 내용은 전 직원들에게 공유되어야 하므로 `모든 팀은 최소 1명 이상`의 직원을 워크숍에 참석시켜야 합니다.
2. 워크숍 기간 동안, 회사의 매출 손실을 최소화하는 것이 중요하므로 워크숍에 참석하는 직원들의 하루평균 매출액의 합이 최소가 되어야 합니다.

위 그림의 조직도에서 회색으로 색칠된 `1번, 7번, 10번` 직원을 워크숍에 참석시키면 모든 팀에서 최소 한 명 이상의 직원을 참석시킨 것이 되며, 해당 직원들의 하루평균 매출액의 합은 `44(14+13+17)원` 입니다. `10번 직원은 C팀과 D팀 모두에 속해 있으므로, 두 팀에서 모두 참석한 것으로 인정됩니다.`

------

#### **[문제]**

직원들의 하루평균 매출액 값을 담은 배열 sales, 직원들의 `팀장-팀원`의 관계를 나타내는 2차원 배열 links가 매개변수로 주어집니다. 이때, 모든 팀에서 최소 한 명 이상 워크숍에 참석하면서, 참석하는 직원들의 하루평균 매출액의 합을 최소로 하려고 합니다. 그렇게 최소화된 매출액의 합을 구해서 return 하도록 solution 함수를 완성해 주세요.

#### **[제한사항]**

- sales 배열의 크기는 2 이상 300,000 이하입니다. sales 배열의 크기는 CEO를 포함한 전체 직원 수와 같습니다.
  - sales 배열은 각 직원들의 하루평균 매출액을 담고 있으며, `1번` 직원부터 직원번호 순서대로 주어집니다.
  - sales 배열의 각 원소의 값은 0 이상 10,000 이하인 정수입니다.
- links 배열의 크기는 `sales 배열의 크기 - 1` 입니다. 즉, 전체 직원 수보다 1이 작습니다.
- links 배열의 각 원소는 [a, b] 형식입니다.
  - a는 팀장의 직원번호, b는 a팀장이 관리하는 팀원의 직원번호이며, a와 b는 서로 다른 자연수입니다.
  - 1 ≤ `a` ≤ `sales 배열의 크기` 입니다.
  - 2 ≤ `b` ≤ `sales 배열의 크기` 입니다.
  - 직원번호 1은 CEO로 정해져 있고 CEO는 항상 팀장으므로 b ≠ 1 입니다.
  - links 배열로 만들어지는 조직도는 하나의 트리 구조 형태입니다.
- 정답으로 return 되는 값은 231 - 1 이하인 자연수임이 보장됩니다.

------

##### **[입출력 예]**

| sales                                    | links                                                        | result |
| ---------------------------------------- | ------------------------------------------------------------ | ------ |
| [14, 17, 15, 18, 19, 14, 13, 16, 28, 17] | [[10, 8], [1, 9], [9, 7], [5, 4], [1, 5], [5, 10], [10, 6], [1, 3], [10, 2]] | 44     |
| [5, 6, 5, 3, 4]                          | [[2,3], [1,4], [2,5], [1,2]]                                 | 6      |
| [5, 6, 5, 1, 4]                          | [[2,3], [1,4], [2,5], [1,2]]                                 | 5      |
| [10, 10, 1, 1]                           | [[3,2], [4,3], [1,4]]                                        | 2      |

##### **입출력 예에 대한 설명**

------

**입출력 예 #1**
입출력 예 #1
문제 예시와 같습니다.

**입출력 예 #2**
직원번호가 2인 직원 한 명을 워크숍에 참석시키는 것이 최선이며, 2번 직원의 하루평균 매출액은 6원입니다. 따라서 6을 return 해주어야 합니다.
![2021_kakao_sales_02.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/604f5744-1d63-426d-8286-4a076c305bac/2021_kakao_sales_02.png)

**입출력 예 #3**
직원번호가 4, 5인 직원 두 명을 워크숍에 참석시키는 것이 최선이며, 4번, 5번 직원의 하루평균 매출액의 합은 5(1+4)원 입니다. 따라서 5를 return 해주어야 합니다.
![2021_kakao_sales_03.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/07606ff5-42a6-45a4-a54a-cb63d119601e/2021_kakao_sales_03.png)

**입출력 예 #4**
직원번호가 3, 4인 직원 두 명을 워크숍에 참석시키는 것이 최선이며, 3번, 4번 직원의 하루평균 매출액의 합은 2(1+1)원 입니다. 따라서 2를 return 해주어야 합니다.
![2021_kakao_sales_04.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/cf0e8c38-09c7-41c4-84c6-7fc8f930ada1/2021_kakao_sales_04.png)

